# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._inputs import *

__all__ = ['URLFilteringRulesArgs', 'URLFilteringRules']

@pulumi.input_type
class URLFilteringRulesArgs:
    def __init__(__self__, *,
                 order: pulumi.Input[int],
                 protocols: pulumi.Input[Sequence[pulumi.Input[str]]],
                 action: Optional[pulumi.Input[str]] = None,
                 block_override: Optional[pulumi.Input[bool]] = None,
                 ciparule: Optional[pulumi.Input[bool]] = None,
                 departments: Optional[pulumi.Input['URLFilteringRulesDepartmentsArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 device_groups: Optional[pulumi.Input['URLFilteringRulesDeviceGroupsArgs']] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 devices: Optional[pulumi.Input['URLFilteringRulesDevicesArgs']] = None,
                 end_user_notification_url: Optional[pulumi.Input[str]] = None,
                 enforce_time_validity: Optional[pulumi.Input[bool]] = None,
                 groups: Optional[pulumi.Input['URLFilteringRulesGroupsArgs']] = None,
                 labels: Optional[pulumi.Input['URLFilteringRulesLabelsArgs']] = None,
                 last_modified_bies: Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesLastModifiedByArgs']]]] = None,
                 last_modified_time: Optional[pulumi.Input[int]] = None,
                 location_groups: Optional[pulumi.Input['URLFilteringRulesLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['URLFilteringRulesLocationsArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 override_groups: Optional[pulumi.Input['URLFilteringRulesOverrideGroupsArgs']] = None,
                 override_users: Optional[pulumi.Input['URLFilteringRulesOverrideUsersArgs']] = None,
                 rank: Optional[pulumi.Input[int]] = None,
                 request_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 size_quota: Optional[pulumi.Input[int]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_quota: Optional[pulumi.Input[int]] = None,
                 time_windows: Optional[pulumi.Input['URLFilteringRulesTimeWindowsArgs']] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_agent_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 users: Optional[pulumi.Input['URLFilteringRulesUsersArgs']] = None,
                 validity_end_time: Optional[pulumi.Input[int]] = None,
                 validity_start_time: Optional[pulumi.Input[int]] = None,
                 validity_time_zone_id: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a URLFilteringRules resource.
        :param pulumi.Input[int] order: Order of execution of rule with respect to other URL Filtering rules
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocols: Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`.
        :param pulumi.Input[str] action: Action taken when traffic matches rule criteria. Supported values: `ANY`, `NONE`, `BLOCK`, `CAUTION`, `ALLOW`, `ICAP_RESPONSE`
        :param pulumi.Input[bool] block_override: When set to true, a `BLOCK` action triggered by the rule could be overridden. If true and both overrideGroup and overrideUsers are not set, the `BLOCK` triggered by this rule could be overridden for any users. If block)Override is not set, `BLOCK` action cannot be overridden.
        :param pulumi.Input[bool] ciparule: If set to true, the CIPA Compliance rule is enabled
        :param pulumi.Input['URLFilteringRulesDepartmentsArgs'] departments: The departments to which the Firewall Filtering policy rule applies
        :param pulumi.Input[str] description: Additional information about the rule
        :param pulumi.Input['URLFilteringRulesDeviceGroupsArgs'] device_groups: list of device groups
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        :param pulumi.Input['URLFilteringRulesDevicesArgs'] devices: list of devices
        :param pulumi.Input[str] end_user_notification_url: URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or 'overrideGroups' is specified.
        :param pulumi.Input[bool] enforce_time_validity: Enforce a set a validity time period for the URL Filtering rule.
        :param pulumi.Input['URLFilteringRulesGroupsArgs'] groups: The groups to which the Firewall Filtering policy rule applies
        :param pulumi.Input['URLFilteringRulesLabelsArgs'] labels: list of labels
        :param pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesLastModifiedByArgs']]] last_modified_bies: Who modified the rule last
        :param pulumi.Input[int] last_modified_time: When the rule was last modified
        :param pulumi.Input['URLFilteringRulesLocationGroupsArgs'] location_groups: The location groups to which the Firewall Filtering policy rule applies
        :param pulumi.Input['URLFilteringRulesLocationsArgs'] locations: The locations to which the Firewall Filtering policy rule applies
        :param pulumi.Input[str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input['URLFilteringRulesOverrideGroupsArgs'] override_groups: Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any group.
        :param pulumi.Input['URLFilteringRulesOverrideUsersArgs'] override_users: Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any user.
        :param pulumi.Input[int] rank: Admin rank of the admin who creates this rule
        :param pulumi.Input[Sequence[pulumi.Input[str]]] request_methods: Request method for which the rule must be applied. If not set, rule will be applied to all methods
        :param pulumi.Input[int] size_quota: Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        :param pulumi.Input[str] state: Rule State
        :param pulumi.Input[int] time_quota: Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        :param pulumi.Input['URLFilteringRulesTimeWindowsArgs'] time_windows: The time interval in which the Firewall Filtering policy rule applies
        :param pulumi.Input[Sequence[pulumi.Input[str]]] url_categories: List of URL categories for which rule must be applied
        :param pulumi.Input['URLFilteringRulesUsersArgs'] users: The users to which the Firewall Filtering policy rule applies
        :param pulumi.Input[int] validity_end_time: If `enforceTimeValidity` is set to true, the URL Filtering rule will cease to be valid on this end date and time.
        :param pulumi.Input[int] validity_start_time: If enforceTimeValidity is set to true, the URL Filtering rule will be valid starting on this date and time.
        :param pulumi.Input[str] validity_time_zone_id: If `enforceTimeValidity` is set to true, the URL Filtering rule date and time will be valid based on this time zone ID.
        """
        pulumi.set(__self__, "order", order)
        pulumi.set(__self__, "protocols", protocols)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if block_override is not None:
            pulumi.set(__self__, "block_override", block_override)
        if ciparule is not None:
            pulumi.set(__self__, "ciparule", ciparule)
        if departments is not None:
            pulumi.set(__self__, "departments", departments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_groups is not None:
            pulumi.set(__self__, "device_groups", device_groups)
        if device_trust_levels is not None:
            pulumi.set(__self__, "device_trust_levels", device_trust_levels)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if end_user_notification_url is not None:
            pulumi.set(__self__, "end_user_notification_url", end_user_notification_url)
        if enforce_time_validity is not None:
            pulumi.set(__self__, "enforce_time_validity", enforce_time_validity)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if last_modified_bies is not None:
            pulumi.set(__self__, "last_modified_bies", last_modified_bies)
        if last_modified_time is not None:
            pulumi.set(__self__, "last_modified_time", last_modified_time)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_groups is not None:
            pulumi.set(__self__, "override_groups", override_groups)
        if override_users is not None:
            pulumi.set(__self__, "override_users", override_users)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if request_methods is not None:
            pulumi.set(__self__, "request_methods", request_methods)
        if size_quota is not None:
            pulumi.set(__self__, "size_quota", size_quota)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_quota is not None:
            pulumi.set(__self__, "time_quota", time_quota)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)
        if url_categories is not None:
            pulumi.set(__self__, "url_categories", url_categories)
        if user_agent_types is not None:
            pulumi.set(__self__, "user_agent_types", user_agent_types)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if validity_end_time is not None:
            pulumi.set(__self__, "validity_end_time", validity_end_time)
        if validity_start_time is not None:
            pulumi.set(__self__, "validity_start_time", validity_start_time)
        if validity_time_zone_id is not None:
            pulumi.set(__self__, "validity_time_zone_id", validity_time_zone_id)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[int]:
        """
        Order of execution of rule with respect to other URL Filtering rules
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter
    def protocols(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action taken when traffic matches rule criteria. Supported values: `ANY`, `NONE`, `BLOCK`, `CAUTION`, `ALLOW`, `ICAP_RESPONSE`
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="blockOverride")
    def block_override(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, a `BLOCK` action triggered by the rule could be overridden. If true and both overrideGroup and overrideUsers are not set, the `BLOCK` triggered by this rule could be overridden for any users. If block)Override is not set, `BLOCK` action cannot be overridden.
        """
        return pulumi.get(self, "block_override")

    @block_override.setter
    def block_override(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_override", value)

    @property
    @pulumi.getter
    def ciparule(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, the CIPA Compliance rule is enabled
        """
        return pulumi.get(self, "ciparule")

    @ciparule.setter
    def ciparule(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ciparule", value)

    @property
    @pulumi.getter
    def departments(self) -> Optional[pulumi.Input['URLFilteringRulesDepartmentsArgs']]:
        """
        The departments to which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "departments")

    @departments.setter
    def departments(self, value: Optional[pulumi.Input['URLFilteringRulesDepartmentsArgs']]):
        pulumi.set(self, "departments", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Optional[pulumi.Input['URLFilteringRulesDeviceGroupsArgs']]:
        """
        list of device groups
        """
        return pulumi.get(self, "device_groups")

    @device_groups.setter
    def device_groups(self, value: Optional[pulumi.Input['URLFilteringRulesDeviceGroupsArgs']]):
        pulumi.set(self, "device_groups", value)

    @property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        """
        return pulumi.get(self, "device_trust_levels")

    @device_trust_levels.setter
    def device_trust_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_trust_levels", value)

    @property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input['URLFilteringRulesDevicesArgs']]:
        """
        list of devices
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input['URLFilteringRulesDevicesArgs']]):
        pulumi.set(self, "devices", value)

    @property
    @pulumi.getter(name="endUserNotificationUrl")
    def end_user_notification_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or 'overrideGroups' is specified.
        """
        return pulumi.get(self, "end_user_notification_url")

    @end_user_notification_url.setter
    def end_user_notification_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_user_notification_url", value)

    @property
    @pulumi.getter(name="enforceTimeValidity")
    def enforce_time_validity(self) -> Optional[pulumi.Input[bool]]:
        """
        Enforce a set a validity time period for the URL Filtering rule.
        """
        return pulumi.get(self, "enforce_time_validity")

    @enforce_time_validity.setter
    def enforce_time_validity(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enforce_time_validity", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input['URLFilteringRulesGroupsArgs']]:
        """
        The groups to which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input['URLFilteringRulesGroupsArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['URLFilteringRulesLabelsArgs']]:
        """
        list of labels
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['URLFilteringRulesLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="lastModifiedBies")
    def last_modified_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesLastModifiedByArgs']]]]:
        """
        Who modified the rule last
        """
        return pulumi.get(self, "last_modified_bies")

    @last_modified_bies.setter
    def last_modified_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesLastModifiedByArgs']]]]):
        pulumi.set(self, "last_modified_bies", value)

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> Optional[pulumi.Input[int]]:
        """
        When the rule was last modified
        """
        return pulumi.get(self, "last_modified_time")

    @last_modified_time.setter
    def last_modified_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "last_modified_time", value)

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['URLFilteringRulesLocationGroupsArgs']]:
        """
        The location groups to which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['URLFilteringRulesLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['URLFilteringRulesLocationsArgs']]:
        """
        The locations to which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['URLFilteringRulesLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="overrideGroups")
    def override_groups(self) -> Optional[pulumi.Input['URLFilteringRulesOverrideGroupsArgs']]:
        """
        Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any group.
        """
        return pulumi.get(self, "override_groups")

    @override_groups.setter
    def override_groups(self, value: Optional[pulumi.Input['URLFilteringRulesOverrideGroupsArgs']]):
        pulumi.set(self, "override_groups", value)

    @property
    @pulumi.getter(name="overrideUsers")
    def override_users(self) -> Optional[pulumi.Input['URLFilteringRulesOverrideUsersArgs']]:
        """
        Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any user.
        """
        return pulumi.get(self, "override_users")

    @override_users.setter
    def override_users(self, value: Optional[pulumi.Input['URLFilteringRulesOverrideUsersArgs']]):
        pulumi.set(self, "override_users", value)

    @property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[int]]:
        """
        Admin rank of the admin who creates this rule
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rank", value)

    @property
    @pulumi.getter(name="requestMethods")
    def request_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Request method for which the rule must be applied. If not set, rule will be applied to all methods
        """
        return pulumi.get(self, "request_methods")

    @request_methods.setter
    def request_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "request_methods", value)

    @property
    @pulumi.getter(name="sizeQuota")
    def size_quota(self) -> Optional[pulumi.Input[int]]:
        """
        Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        """
        return pulumi.get(self, "size_quota")

    @size_quota.setter
    def size_quota(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_quota", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Rule State
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeQuota")
    def time_quota(self) -> Optional[pulumi.Input[int]]:
        """
        Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        """
        return pulumi.get(self, "time_quota")

    @time_quota.setter
    def time_quota(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_quota", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input['URLFilteringRulesTimeWindowsArgs']]:
        """
        The time interval in which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input['URLFilteringRulesTimeWindowsArgs']]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of URL categories for which rule must be applied
        """
        return pulumi.get(self, "url_categories")

    @url_categories.setter
    def url_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "url_categories", value)

    @property
    @pulumi.getter(name="userAgentTypes")
    def user_agent_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "user_agent_types")

    @user_agent_types.setter
    def user_agent_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_agent_types", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input['URLFilteringRulesUsersArgs']]:
        """
        The users to which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input['URLFilteringRulesUsersArgs']]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter(name="validityEndTime")
    def validity_end_time(self) -> Optional[pulumi.Input[int]]:
        """
        If `enforceTimeValidity` is set to true, the URL Filtering rule will cease to be valid on this end date and time.
        """
        return pulumi.get(self, "validity_end_time")

    @validity_end_time.setter
    def validity_end_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "validity_end_time", value)

    @property
    @pulumi.getter(name="validityStartTime")
    def validity_start_time(self) -> Optional[pulumi.Input[int]]:
        """
        If enforceTimeValidity is set to true, the URL Filtering rule will be valid starting on this date and time.
        """
        return pulumi.get(self, "validity_start_time")

    @validity_start_time.setter
    def validity_start_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "validity_start_time", value)

    @property
    @pulumi.getter(name="validityTimeZoneId")
    def validity_time_zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        If `enforceTimeValidity` is set to true, the URL Filtering rule date and time will be valid based on this time zone ID.
        """
        return pulumi.get(self, "validity_time_zone_id")

    @validity_time_zone_id.setter
    def validity_time_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validity_time_zone_id", value)


@pulumi.input_type
class _URLFilteringRulesState:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 block_override: Optional[pulumi.Input[bool]] = None,
                 ciparule: Optional[pulumi.Input[bool]] = None,
                 departments: Optional[pulumi.Input['URLFilteringRulesDepartmentsArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 device_groups: Optional[pulumi.Input['URLFilteringRulesDeviceGroupsArgs']] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 devices: Optional[pulumi.Input['URLFilteringRulesDevicesArgs']] = None,
                 end_user_notification_url: Optional[pulumi.Input[str]] = None,
                 enforce_time_validity: Optional[pulumi.Input[bool]] = None,
                 groups: Optional[pulumi.Input['URLFilteringRulesGroupsArgs']] = None,
                 labels: Optional[pulumi.Input['URLFilteringRulesLabelsArgs']] = None,
                 last_modified_bies: Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesLastModifiedByArgs']]]] = None,
                 last_modified_time: Optional[pulumi.Input[int]] = None,
                 location_groups: Optional[pulumi.Input['URLFilteringRulesLocationGroupsArgs']] = None,
                 locations: Optional[pulumi.Input['URLFilteringRulesLocationsArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 override_groups: Optional[pulumi.Input['URLFilteringRulesOverrideGroupsArgs']] = None,
                 override_users: Optional[pulumi.Input['URLFilteringRulesOverrideUsersArgs']] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 rank: Optional[pulumi.Input[int]] = None,
                 request_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 rule_id: Optional[pulumi.Input[int]] = None,
                 size_quota: Optional[pulumi.Input[int]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_quota: Optional[pulumi.Input[int]] = None,
                 time_windows: Optional[pulumi.Input['URLFilteringRulesTimeWindowsArgs']] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_agent_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 users: Optional[pulumi.Input['URLFilteringRulesUsersArgs']] = None,
                 validity_end_time: Optional[pulumi.Input[int]] = None,
                 validity_start_time: Optional[pulumi.Input[int]] = None,
                 validity_time_zone_id: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering URLFilteringRules resources.
        :param pulumi.Input[str] action: Action taken when traffic matches rule criteria. Supported values: `ANY`, `NONE`, `BLOCK`, `CAUTION`, `ALLOW`, `ICAP_RESPONSE`
        :param pulumi.Input[bool] block_override: When set to true, a `BLOCK` action triggered by the rule could be overridden. If true and both overrideGroup and overrideUsers are not set, the `BLOCK` triggered by this rule could be overridden for any users. If block)Override is not set, `BLOCK` action cannot be overridden.
        :param pulumi.Input[bool] ciparule: If set to true, the CIPA Compliance rule is enabled
        :param pulumi.Input['URLFilteringRulesDepartmentsArgs'] departments: The departments to which the Firewall Filtering policy rule applies
        :param pulumi.Input[str] description: Additional information about the rule
        :param pulumi.Input['URLFilteringRulesDeviceGroupsArgs'] device_groups: list of device groups
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        :param pulumi.Input['URLFilteringRulesDevicesArgs'] devices: list of devices
        :param pulumi.Input[str] end_user_notification_url: URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or 'overrideGroups' is specified.
        :param pulumi.Input[bool] enforce_time_validity: Enforce a set a validity time period for the URL Filtering rule.
        :param pulumi.Input['URLFilteringRulesGroupsArgs'] groups: The groups to which the Firewall Filtering policy rule applies
        :param pulumi.Input['URLFilteringRulesLabelsArgs'] labels: list of labels
        :param pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesLastModifiedByArgs']]] last_modified_bies: Who modified the rule last
        :param pulumi.Input[int] last_modified_time: When the rule was last modified
        :param pulumi.Input['URLFilteringRulesLocationGroupsArgs'] location_groups: The location groups to which the Firewall Filtering policy rule applies
        :param pulumi.Input['URLFilteringRulesLocationsArgs'] locations: The locations to which the Firewall Filtering policy rule applies
        :param pulumi.Input[str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input[int] order: Order of execution of rule with respect to other URL Filtering rules
        :param pulumi.Input['URLFilteringRulesOverrideGroupsArgs'] override_groups: Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any group.
        :param pulumi.Input['URLFilteringRulesOverrideUsersArgs'] override_users: Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any user.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocols: Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`.
        :param pulumi.Input[int] rank: Admin rank of the admin who creates this rule
        :param pulumi.Input[Sequence[pulumi.Input[str]]] request_methods: Request method for which the rule must be applied. If not set, rule will be applied to all methods
        :param pulumi.Input[int] rule_id: URL Filtering Rule ID
        :param pulumi.Input[int] size_quota: Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        :param pulumi.Input[str] state: Rule State
        :param pulumi.Input[int] time_quota: Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        :param pulumi.Input['URLFilteringRulesTimeWindowsArgs'] time_windows: The time interval in which the Firewall Filtering policy rule applies
        :param pulumi.Input[Sequence[pulumi.Input[str]]] url_categories: List of URL categories for which rule must be applied
        :param pulumi.Input['URLFilteringRulesUsersArgs'] users: The users to which the Firewall Filtering policy rule applies
        :param pulumi.Input[int] validity_end_time: If `enforceTimeValidity` is set to true, the URL Filtering rule will cease to be valid on this end date and time.
        :param pulumi.Input[int] validity_start_time: If enforceTimeValidity is set to true, the URL Filtering rule will be valid starting on this date and time.
        :param pulumi.Input[str] validity_time_zone_id: If `enforceTimeValidity` is set to true, the URL Filtering rule date and time will be valid based on this time zone ID.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if block_override is not None:
            pulumi.set(__self__, "block_override", block_override)
        if ciparule is not None:
            pulumi.set(__self__, "ciparule", ciparule)
        if departments is not None:
            pulumi.set(__self__, "departments", departments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_groups is not None:
            pulumi.set(__self__, "device_groups", device_groups)
        if device_trust_levels is not None:
            pulumi.set(__self__, "device_trust_levels", device_trust_levels)
        if devices is not None:
            pulumi.set(__self__, "devices", devices)
        if end_user_notification_url is not None:
            pulumi.set(__self__, "end_user_notification_url", end_user_notification_url)
        if enforce_time_validity is not None:
            pulumi.set(__self__, "enforce_time_validity", enforce_time_validity)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if last_modified_bies is not None:
            pulumi.set(__self__, "last_modified_bies", last_modified_bies)
        if last_modified_time is not None:
            pulumi.set(__self__, "last_modified_time", last_modified_time)
        if location_groups is not None:
            pulumi.set(__self__, "location_groups", location_groups)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if override_groups is not None:
            pulumi.set(__self__, "override_groups", override_groups)
        if override_users is not None:
            pulumi.set(__self__, "override_users", override_users)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)
        if request_methods is not None:
            pulumi.set(__self__, "request_methods", request_methods)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if size_quota is not None:
            pulumi.set(__self__, "size_quota", size_quota)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_quota is not None:
            pulumi.set(__self__, "time_quota", time_quota)
        if time_windows is not None:
            pulumi.set(__self__, "time_windows", time_windows)
        if url_categories is not None:
            pulumi.set(__self__, "url_categories", url_categories)
        if user_agent_types is not None:
            pulumi.set(__self__, "user_agent_types", user_agent_types)
        if users is not None:
            pulumi.set(__self__, "users", users)
        if validity_end_time is not None:
            pulumi.set(__self__, "validity_end_time", validity_end_time)
        if validity_start_time is not None:
            pulumi.set(__self__, "validity_start_time", validity_start_time)
        if validity_time_zone_id is not None:
            pulumi.set(__self__, "validity_time_zone_id", validity_time_zone_id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action taken when traffic matches rule criteria. Supported values: `ANY`, `NONE`, `BLOCK`, `CAUTION`, `ALLOW`, `ICAP_RESPONSE`
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="blockOverride")
    def block_override(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, a `BLOCK` action triggered by the rule could be overridden. If true and both overrideGroup and overrideUsers are not set, the `BLOCK` triggered by this rule could be overridden for any users. If block)Override is not set, `BLOCK` action cannot be overridden.
        """
        return pulumi.get(self, "block_override")

    @block_override.setter
    def block_override(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_override", value)

    @property
    @pulumi.getter
    def ciparule(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, the CIPA Compliance rule is enabled
        """
        return pulumi.get(self, "ciparule")

    @ciparule.setter
    def ciparule(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ciparule", value)

    @property
    @pulumi.getter
    def departments(self) -> Optional[pulumi.Input['URLFilteringRulesDepartmentsArgs']]:
        """
        The departments to which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "departments")

    @departments.setter
    def departments(self, value: Optional[pulumi.Input['URLFilteringRulesDepartmentsArgs']]):
        pulumi.set(self, "departments", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the rule
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> Optional[pulumi.Input['URLFilteringRulesDeviceGroupsArgs']]:
        """
        list of device groups
        """
        return pulumi.get(self, "device_groups")

    @device_groups.setter
    def device_groups(self, value: Optional[pulumi.Input['URLFilteringRulesDeviceGroupsArgs']]):
        pulumi.set(self, "device_groups", value)

    @property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        """
        return pulumi.get(self, "device_trust_levels")

    @device_trust_levels.setter
    def device_trust_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "device_trust_levels", value)

    @property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input['URLFilteringRulesDevicesArgs']]:
        """
        list of devices
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input['URLFilteringRulesDevicesArgs']]):
        pulumi.set(self, "devices", value)

    @property
    @pulumi.getter(name="endUserNotificationUrl")
    def end_user_notification_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or 'overrideGroups' is specified.
        """
        return pulumi.get(self, "end_user_notification_url")

    @end_user_notification_url.setter
    def end_user_notification_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_user_notification_url", value)

    @property
    @pulumi.getter(name="enforceTimeValidity")
    def enforce_time_validity(self) -> Optional[pulumi.Input[bool]]:
        """
        Enforce a set a validity time period for the URL Filtering rule.
        """
        return pulumi.get(self, "enforce_time_validity")

    @enforce_time_validity.setter
    def enforce_time_validity(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enforce_time_validity", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input['URLFilteringRulesGroupsArgs']]:
        """
        The groups to which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input['URLFilteringRulesGroupsArgs']]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input['URLFilteringRulesLabelsArgs']]:
        """
        list of labels
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input['URLFilteringRulesLabelsArgs']]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="lastModifiedBies")
    def last_modified_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesLastModifiedByArgs']]]]:
        """
        Who modified the rule last
        """
        return pulumi.get(self, "last_modified_bies")

    @last_modified_bies.setter
    def last_modified_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['URLFilteringRulesLastModifiedByArgs']]]]):
        pulumi.set(self, "last_modified_bies", value)

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> Optional[pulumi.Input[int]]:
        """
        When the rule was last modified
        """
        return pulumi.get(self, "last_modified_time")

    @last_modified_time.setter
    def last_modified_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "last_modified_time", value)

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> Optional[pulumi.Input['URLFilteringRulesLocationGroupsArgs']]:
        """
        The location groups to which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "location_groups")

    @location_groups.setter
    def location_groups(self, value: Optional[pulumi.Input['URLFilteringRulesLocationGroupsArgs']]):
        pulumi.set(self, "location_groups", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['URLFilteringRulesLocationsArgs']]:
        """
        The locations to which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['URLFilteringRulesLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[pulumi.Input[int]]:
        """
        Order of execution of rule with respect to other URL Filtering rules
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="overrideGroups")
    def override_groups(self) -> Optional[pulumi.Input['URLFilteringRulesOverrideGroupsArgs']]:
        """
        Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any group.
        """
        return pulumi.get(self, "override_groups")

    @override_groups.setter
    def override_groups(self, value: Optional[pulumi.Input['URLFilteringRulesOverrideGroupsArgs']]):
        pulumi.set(self, "override_groups", value)

    @property
    @pulumi.getter(name="overrideUsers")
    def override_users(self) -> Optional[pulumi.Input['URLFilteringRulesOverrideUsersArgs']]:
        """
        Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any user.
        """
        return pulumi.get(self, "override_users")

    @override_users.setter
    def override_users(self, value: Optional[pulumi.Input['URLFilteringRulesOverrideUsersArgs']]):
        pulumi.set(self, "override_users", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[int]]:
        """
        Admin rank of the admin who creates this rule
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rank", value)

    @property
    @pulumi.getter(name="requestMethods")
    def request_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Request method for which the rule must be applied. If not set, rule will be applied to all methods
        """
        return pulumi.get(self, "request_methods")

    @request_methods.setter
    def request_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "request_methods", value)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[int]]:
        """
        URL Filtering Rule ID
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter(name="sizeQuota")
    def size_quota(self) -> Optional[pulumi.Input[int]]:
        """
        Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        """
        return pulumi.get(self, "size_quota")

    @size_quota.setter
    def size_quota(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_quota", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Rule State
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeQuota")
    def time_quota(self) -> Optional[pulumi.Input[int]]:
        """
        Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        """
        return pulumi.get(self, "time_quota")

    @time_quota.setter
    def time_quota(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_quota", value)

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Optional[pulumi.Input['URLFilteringRulesTimeWindowsArgs']]:
        """
        The time interval in which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "time_windows")

    @time_windows.setter
    def time_windows(self, value: Optional[pulumi.Input['URLFilteringRulesTimeWindowsArgs']]):
        pulumi.set(self, "time_windows", value)

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of URL categories for which rule must be applied
        """
        return pulumi.get(self, "url_categories")

    @url_categories.setter
    def url_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "url_categories", value)

    @property
    @pulumi.getter(name="userAgentTypes")
    def user_agent_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "user_agent_types")

    @user_agent_types.setter
    def user_agent_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_agent_types", value)

    @property
    @pulumi.getter
    def users(self) -> Optional[pulumi.Input['URLFilteringRulesUsersArgs']]:
        """
        The users to which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: Optional[pulumi.Input['URLFilteringRulesUsersArgs']]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter(name="validityEndTime")
    def validity_end_time(self) -> Optional[pulumi.Input[int]]:
        """
        If `enforceTimeValidity` is set to true, the URL Filtering rule will cease to be valid on this end date and time.
        """
        return pulumi.get(self, "validity_end_time")

    @validity_end_time.setter
    def validity_end_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "validity_end_time", value)

    @property
    @pulumi.getter(name="validityStartTime")
    def validity_start_time(self) -> Optional[pulumi.Input[int]]:
        """
        If enforceTimeValidity is set to true, the URL Filtering rule will be valid starting on this date and time.
        """
        return pulumi.get(self, "validity_start_time")

    @validity_start_time.setter
    def validity_start_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "validity_start_time", value)

    @property
    @pulumi.getter(name="validityTimeZoneId")
    def validity_time_zone_id(self) -> Optional[pulumi.Input[str]]:
        """
        If `enforceTimeValidity` is set to true, the URL Filtering rule date and time will be valid based on this time zone ID.
        """
        return pulumi.get(self, "validity_time_zone_id")

    @validity_time_zone_id.setter
    def validity_time_zone_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validity_time_zone_id", value)


class URLFilteringRules(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 action: Optional[pulumi.Input[str]] = None,
                 block_override: Optional[pulumi.Input[bool]] = None,
                 ciparule: Optional[pulumi.Input[bool]] = None,
                 departments: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesDepartmentsArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 device_groups: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesDeviceGroupsArgs']]] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 devices: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesDevicesArgs']]] = None,
                 end_user_notification_url: Optional[pulumi.Input[str]] = None,
                 enforce_time_validity: Optional[pulumi.Input[bool]] = None,
                 groups: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesGroupsArgs']]] = None,
                 labels: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesLabelsArgs']]] = None,
                 last_modified_bies: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['URLFilteringRulesLastModifiedByArgs']]]]] = None,
                 last_modified_time: Optional[pulumi.Input[int]] = None,
                 location_groups: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesLocationGroupsArgs']]] = None,
                 locations: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesLocationsArgs']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 override_groups: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesOverrideGroupsArgs']]] = None,
                 override_users: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesOverrideUsersArgs']]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 rank: Optional[pulumi.Input[int]] = None,
                 request_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 size_quota: Optional[pulumi.Input[int]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_quota: Optional[pulumi.Input[int]] = None,
                 time_windows: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesTimeWindowsArgs']]] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_agent_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 users: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesUsersArgs']]] = None,
                 validity_end_time: Optional[pulumi.Input[int]] = None,
                 validity_start_time: Optional[pulumi.Input[int]] = None,
                 validity_time_zone_id: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        The **zia_url_filtering_rules** resource creates and manages a URL filtering rules within the Zscaler Internet Access cloud.

        ## Example Usage

        ```python
        import pulumi
        import zscaler_pulumi_zia as zia

        # URL filtering rules
        block_streaming = zia.url_filtering.URLFilteringRules("blockStreaming",
            action="BLOCK",
            description="Block Video Streaming.",
            device_trust_levels=[
                "UNKNOWN_DEVICETRUSTLEVEL",
                "LOW_TRUST",
                "MEDIUM_TRUST",
                "HIGH_TRUST",
            ],
            order=2,
            protocols=["ANY_RULE"],
            request_methods=[
                "CONNECT",
                "DELETE",
                "GET",
                "HEAD",
                "OPTIONS",
                "OTHER",
                "POST",
                "PUT",
                "TRACE",
            ],
            state="ENABLED",
            url_categories=["ANY"])
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] action: Action taken when traffic matches rule criteria. Supported values: `ANY`, `NONE`, `BLOCK`, `CAUTION`, `ALLOW`, `ICAP_RESPONSE`
        :param pulumi.Input[bool] block_override: When set to true, a `BLOCK` action triggered by the rule could be overridden. If true and both overrideGroup and overrideUsers are not set, the `BLOCK` triggered by this rule could be overridden for any users. If block)Override is not set, `BLOCK` action cannot be overridden.
        :param pulumi.Input[bool] ciparule: If set to true, the CIPA Compliance rule is enabled
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesDepartmentsArgs']] departments: The departments to which the Firewall Filtering policy rule applies
        :param pulumi.Input[str] description: Additional information about the rule
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesDeviceGroupsArgs']] device_groups: list of device groups
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesDevicesArgs']] devices: list of devices
        :param pulumi.Input[str] end_user_notification_url: URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or 'overrideGroups' is specified.
        :param pulumi.Input[bool] enforce_time_validity: Enforce a set a validity time period for the URL Filtering rule.
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesGroupsArgs']] groups: The groups to which the Firewall Filtering policy rule applies
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesLabelsArgs']] labels: list of labels
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['URLFilteringRulesLastModifiedByArgs']]]] last_modified_bies: Who modified the rule last
        :param pulumi.Input[int] last_modified_time: When the rule was last modified
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesLocationGroupsArgs']] location_groups: The location groups to which the Firewall Filtering policy rule applies
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesLocationsArgs']] locations: The locations to which the Firewall Filtering policy rule applies
        :param pulumi.Input[str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input[int] order: Order of execution of rule with respect to other URL Filtering rules
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesOverrideGroupsArgs']] override_groups: Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any group.
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesOverrideUsersArgs']] override_users: Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any user.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocols: Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`.
        :param pulumi.Input[int] rank: Admin rank of the admin who creates this rule
        :param pulumi.Input[Sequence[pulumi.Input[str]]] request_methods: Request method for which the rule must be applied. If not set, rule will be applied to all methods
        :param pulumi.Input[int] size_quota: Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        :param pulumi.Input[str] state: Rule State
        :param pulumi.Input[int] time_quota: Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesTimeWindowsArgs']] time_windows: The time interval in which the Firewall Filtering policy rule applies
        :param pulumi.Input[Sequence[pulumi.Input[str]]] url_categories: List of URL categories for which rule must be applied
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesUsersArgs']] users: The users to which the Firewall Filtering policy rule applies
        :param pulumi.Input[int] validity_end_time: If `enforceTimeValidity` is set to true, the URL Filtering rule will cease to be valid on this end date and time.
        :param pulumi.Input[int] validity_start_time: If enforceTimeValidity is set to true, the URL Filtering rule will be valid starting on this date and time.
        :param pulumi.Input[str] validity_time_zone_id: If `enforceTimeValidity` is set to true, the URL Filtering rule date and time will be valid based on this time zone ID.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: URLFilteringRulesArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        The **zia_url_filtering_rules** resource creates and manages a URL filtering rules within the Zscaler Internet Access cloud.

        ## Example Usage

        ```python
        import pulumi
        import zscaler_pulumi_zia as zia

        # URL filtering rules
        block_streaming = zia.url_filtering.URLFilteringRules("blockStreaming",
            action="BLOCK",
            description="Block Video Streaming.",
            device_trust_levels=[
                "UNKNOWN_DEVICETRUSTLEVEL",
                "LOW_TRUST",
                "MEDIUM_TRUST",
                "HIGH_TRUST",
            ],
            order=2,
            protocols=["ANY_RULE"],
            request_methods=[
                "CONNECT",
                "DELETE",
                "GET",
                "HEAD",
                "OPTIONS",
                "OTHER",
                "POST",
                "PUT",
                "TRACE",
            ],
            state="ENABLED",
            url_categories=["ANY"])
        ```

        :param str resource_name: The name of the resource.
        :param URLFilteringRulesArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(URLFilteringRulesArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 action: Optional[pulumi.Input[str]] = None,
                 block_override: Optional[pulumi.Input[bool]] = None,
                 ciparule: Optional[pulumi.Input[bool]] = None,
                 departments: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesDepartmentsArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 device_groups: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesDeviceGroupsArgs']]] = None,
                 device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 devices: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesDevicesArgs']]] = None,
                 end_user_notification_url: Optional[pulumi.Input[str]] = None,
                 enforce_time_validity: Optional[pulumi.Input[bool]] = None,
                 groups: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesGroupsArgs']]] = None,
                 labels: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesLabelsArgs']]] = None,
                 last_modified_bies: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['URLFilteringRulesLastModifiedByArgs']]]]] = None,
                 last_modified_time: Optional[pulumi.Input[int]] = None,
                 location_groups: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesLocationGroupsArgs']]] = None,
                 locations: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesLocationsArgs']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 order: Optional[pulumi.Input[int]] = None,
                 override_groups: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesOverrideGroupsArgs']]] = None,
                 override_users: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesOverrideUsersArgs']]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 rank: Optional[pulumi.Input[int]] = None,
                 request_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 size_quota: Optional[pulumi.Input[int]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_quota: Optional[pulumi.Input[int]] = None,
                 time_windows: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesTimeWindowsArgs']]] = None,
                 url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_agent_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 users: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesUsersArgs']]] = None,
                 validity_end_time: Optional[pulumi.Input[int]] = None,
                 validity_start_time: Optional[pulumi.Input[int]] = None,
                 validity_time_zone_id: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = URLFilteringRulesArgs.__new__(URLFilteringRulesArgs)

            __props__.__dict__["action"] = action
            __props__.__dict__["block_override"] = block_override
            __props__.__dict__["ciparule"] = ciparule
            __props__.__dict__["departments"] = departments
            __props__.__dict__["description"] = description
            __props__.__dict__["device_groups"] = device_groups
            __props__.__dict__["device_trust_levels"] = device_trust_levels
            __props__.__dict__["devices"] = devices
            __props__.__dict__["end_user_notification_url"] = end_user_notification_url
            __props__.__dict__["enforce_time_validity"] = enforce_time_validity
            __props__.__dict__["groups"] = groups
            __props__.__dict__["labels"] = labels
            __props__.__dict__["last_modified_bies"] = last_modified_bies
            __props__.__dict__["last_modified_time"] = last_modified_time
            __props__.__dict__["location_groups"] = location_groups
            __props__.__dict__["locations"] = locations
            __props__.__dict__["name"] = name
            if order is None and not opts.urn:
                raise TypeError("Missing required property 'order'")
            __props__.__dict__["order"] = order
            __props__.__dict__["override_groups"] = override_groups
            __props__.__dict__["override_users"] = override_users
            if protocols is None and not opts.urn:
                raise TypeError("Missing required property 'protocols'")
            __props__.__dict__["protocols"] = protocols
            __props__.__dict__["rank"] = rank
            __props__.__dict__["request_methods"] = request_methods
            __props__.__dict__["size_quota"] = size_quota
            __props__.__dict__["state"] = state
            __props__.__dict__["time_quota"] = time_quota
            __props__.__dict__["time_windows"] = time_windows
            __props__.__dict__["url_categories"] = url_categories
            __props__.__dict__["user_agent_types"] = user_agent_types
            __props__.__dict__["users"] = users
            __props__.__dict__["validity_end_time"] = validity_end_time
            __props__.__dict__["validity_start_time"] = validity_start_time
            __props__.__dict__["validity_time_zone_id"] = validity_time_zone_id
            __props__.__dict__["rule_id"] = None
        super(URLFilteringRules, __self__).__init__(
            'zia:URLFiltering/uRLFilteringRules:URLFilteringRules',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            action: Optional[pulumi.Input[str]] = None,
            block_override: Optional[pulumi.Input[bool]] = None,
            ciparule: Optional[pulumi.Input[bool]] = None,
            departments: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesDepartmentsArgs']]] = None,
            description: Optional[pulumi.Input[str]] = None,
            device_groups: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesDeviceGroupsArgs']]] = None,
            device_trust_levels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            devices: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesDevicesArgs']]] = None,
            end_user_notification_url: Optional[pulumi.Input[str]] = None,
            enforce_time_validity: Optional[pulumi.Input[bool]] = None,
            groups: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesGroupsArgs']]] = None,
            labels: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesLabelsArgs']]] = None,
            last_modified_bies: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['URLFilteringRulesLastModifiedByArgs']]]]] = None,
            last_modified_time: Optional[pulumi.Input[int]] = None,
            location_groups: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesLocationGroupsArgs']]] = None,
            locations: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesLocationsArgs']]] = None,
            name: Optional[pulumi.Input[str]] = None,
            order: Optional[pulumi.Input[int]] = None,
            override_groups: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesOverrideGroupsArgs']]] = None,
            override_users: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesOverrideUsersArgs']]] = None,
            protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            rank: Optional[pulumi.Input[int]] = None,
            request_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            rule_id: Optional[pulumi.Input[int]] = None,
            size_quota: Optional[pulumi.Input[int]] = None,
            state: Optional[pulumi.Input[str]] = None,
            time_quota: Optional[pulumi.Input[int]] = None,
            time_windows: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesTimeWindowsArgs']]] = None,
            url_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            user_agent_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            users: Optional[pulumi.Input[pulumi.InputType['URLFilteringRulesUsersArgs']]] = None,
            validity_end_time: Optional[pulumi.Input[int]] = None,
            validity_start_time: Optional[pulumi.Input[int]] = None,
            validity_time_zone_id: Optional[pulumi.Input[str]] = None) -> 'URLFilteringRules':
        """
        Get an existing URLFilteringRules resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] action: Action taken when traffic matches rule criteria. Supported values: `ANY`, `NONE`, `BLOCK`, `CAUTION`, `ALLOW`, `ICAP_RESPONSE`
        :param pulumi.Input[bool] block_override: When set to true, a `BLOCK` action triggered by the rule could be overridden. If true and both overrideGroup and overrideUsers are not set, the `BLOCK` triggered by this rule could be overridden for any users. If block)Override is not set, `BLOCK` action cannot be overridden.
        :param pulumi.Input[bool] ciparule: If set to true, the CIPA Compliance rule is enabled
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesDepartmentsArgs']] departments: The departments to which the Firewall Filtering policy rule applies
        :param pulumi.Input[str] description: Additional information about the rule
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesDeviceGroupsArgs']] device_groups: list of device groups
        :param pulumi.Input[Sequence[pulumi.Input[str]]] device_trust_levels: List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesDevicesArgs']] devices: list of devices
        :param pulumi.Input[str] end_user_notification_url: URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or 'overrideGroups' is specified.
        :param pulumi.Input[bool] enforce_time_validity: Enforce a set a validity time period for the URL Filtering rule.
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesGroupsArgs']] groups: The groups to which the Firewall Filtering policy rule applies
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesLabelsArgs']] labels: list of labels
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['URLFilteringRulesLastModifiedByArgs']]]] last_modified_bies: Who modified the rule last
        :param pulumi.Input[int] last_modified_time: When the rule was last modified
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesLocationGroupsArgs']] location_groups: The location groups to which the Firewall Filtering policy rule applies
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesLocationsArgs']] locations: The locations to which the Firewall Filtering policy rule applies
        :param pulumi.Input[str] name: Name of the Firewall Filtering policy rule
        :param pulumi.Input[int] order: Order of execution of rule with respect to other URL Filtering rules
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesOverrideGroupsArgs']] override_groups: Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any group.
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesOverrideUsersArgs']] override_users: Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any user.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocols: Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`.
        :param pulumi.Input[int] rank: Admin rank of the admin who creates this rule
        :param pulumi.Input[Sequence[pulumi.Input[str]]] request_methods: Request method for which the rule must be applied. If not set, rule will be applied to all methods
        :param pulumi.Input[int] rule_id: URL Filtering Rule ID
        :param pulumi.Input[int] size_quota: Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        :param pulumi.Input[str] state: Rule State
        :param pulumi.Input[int] time_quota: Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesTimeWindowsArgs']] time_windows: The time interval in which the Firewall Filtering policy rule applies
        :param pulumi.Input[Sequence[pulumi.Input[str]]] url_categories: List of URL categories for which rule must be applied
        :param pulumi.Input[pulumi.InputType['URLFilteringRulesUsersArgs']] users: The users to which the Firewall Filtering policy rule applies
        :param pulumi.Input[int] validity_end_time: If `enforceTimeValidity` is set to true, the URL Filtering rule will cease to be valid on this end date and time.
        :param pulumi.Input[int] validity_start_time: If enforceTimeValidity is set to true, the URL Filtering rule will be valid starting on this date and time.
        :param pulumi.Input[str] validity_time_zone_id: If `enforceTimeValidity` is set to true, the URL Filtering rule date and time will be valid based on this time zone ID.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _URLFilteringRulesState.__new__(_URLFilteringRulesState)

        __props__.__dict__["action"] = action
        __props__.__dict__["block_override"] = block_override
        __props__.__dict__["ciparule"] = ciparule
        __props__.__dict__["departments"] = departments
        __props__.__dict__["description"] = description
        __props__.__dict__["device_groups"] = device_groups
        __props__.__dict__["device_trust_levels"] = device_trust_levels
        __props__.__dict__["devices"] = devices
        __props__.__dict__["end_user_notification_url"] = end_user_notification_url
        __props__.__dict__["enforce_time_validity"] = enforce_time_validity
        __props__.__dict__["groups"] = groups
        __props__.__dict__["labels"] = labels
        __props__.__dict__["last_modified_bies"] = last_modified_bies
        __props__.__dict__["last_modified_time"] = last_modified_time
        __props__.__dict__["location_groups"] = location_groups
        __props__.__dict__["locations"] = locations
        __props__.__dict__["name"] = name
        __props__.__dict__["order"] = order
        __props__.__dict__["override_groups"] = override_groups
        __props__.__dict__["override_users"] = override_users
        __props__.__dict__["protocols"] = protocols
        __props__.__dict__["rank"] = rank
        __props__.__dict__["request_methods"] = request_methods
        __props__.__dict__["rule_id"] = rule_id
        __props__.__dict__["size_quota"] = size_quota
        __props__.__dict__["state"] = state
        __props__.__dict__["time_quota"] = time_quota
        __props__.__dict__["time_windows"] = time_windows
        __props__.__dict__["url_categories"] = url_categories
        __props__.__dict__["user_agent_types"] = user_agent_types
        __props__.__dict__["users"] = users
        __props__.__dict__["validity_end_time"] = validity_end_time
        __props__.__dict__["validity_start_time"] = validity_start_time
        __props__.__dict__["validity_time_zone_id"] = validity_time_zone_id
        return URLFilteringRules(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Output[Optional[str]]:
        """
        Action taken when traffic matches rule criteria. Supported values: `ANY`, `NONE`, `BLOCK`, `CAUTION`, `ALLOW`, `ICAP_RESPONSE`
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="blockOverride")
    def block_override(self) -> pulumi.Output[bool]:
        """
        When set to true, a `BLOCK` action triggered by the rule could be overridden. If true and both overrideGroup and overrideUsers are not set, the `BLOCK` triggered by this rule could be overridden for any users. If block)Override is not set, `BLOCK` action cannot be overridden.
        """
        return pulumi.get(self, "block_override")

    @property
    @pulumi.getter
    def ciparule(self) -> pulumi.Output[bool]:
        """
        If set to true, the CIPA Compliance rule is enabled
        """
        return pulumi.get(self, "ciparule")

    @property
    @pulumi.getter
    def departments(self) -> pulumi.Output['outputs.URLFilteringRulesDepartments']:
        """
        The departments to which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "departments")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[str]]:
        """
        Additional information about the rule
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="deviceGroups")
    def device_groups(self) -> pulumi.Output['outputs.URLFilteringRulesDeviceGroups']:
        """
        list of device groups
        """
        return pulumi.get(self, "device_groups")

    @property
    @pulumi.getter(name="deviceTrustLevels")
    def device_trust_levels(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        List of device trust levels for which the rule must be applied. This field is applicable for devices that are managed using Zscaler Client Connector. The trust levels are assigned to the devices based on your posture configurations in the Zscaler Client Connector Portal. If no value is set, this field is ignored during the policy evaluation. Supported values: `ANY`, `UNKNOWN_DEVICETRUSTLEVEL`, `LOW_TRUST`, `MEDIUM_TRUST`, `HIGH_TRUST`
        """
        return pulumi.get(self, "device_trust_levels")

    @property
    @pulumi.getter
    def devices(self) -> pulumi.Output['outputs.URLFilteringRulesDevices']:
        """
        list of devices
        """
        return pulumi.get(self, "devices")

    @property
    @pulumi.getter(name="endUserNotificationUrl")
    def end_user_notification_url(self) -> pulumi.Output[Optional[str]]:
        """
        URL of end user notification page to be displayed when the rule is matched. Not applicable if either 'overrideUsers' or 'overrideGroups' is specified.
        """
        return pulumi.get(self, "end_user_notification_url")

    @property
    @pulumi.getter(name="enforceTimeValidity")
    def enforce_time_validity(self) -> pulumi.Output[bool]:
        """
        Enforce a set a validity time period for the URL Filtering rule.
        """
        return pulumi.get(self, "enforce_time_validity")

    @property
    @pulumi.getter
    def groups(self) -> pulumi.Output['outputs.URLFilteringRulesGroups']:
        """
        The groups to which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def labels(self) -> pulumi.Output['outputs.URLFilteringRulesLabels']:
        """
        list of labels
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="lastModifiedBies")
    def last_modified_bies(self) -> pulumi.Output[Sequence['outputs.URLFilteringRulesLastModifiedBy']]:
        """
        Who modified the rule last
        """
        return pulumi.get(self, "last_modified_bies")

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> pulumi.Output[Optional[int]]:
        """
        When the rule was last modified
        """
        return pulumi.get(self, "last_modified_time")

    @property
    @pulumi.getter(name="locationGroups")
    def location_groups(self) -> pulumi.Output['outputs.URLFilteringRulesLocationGroups']:
        """
        The location groups to which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "location_groups")

    @property
    @pulumi.getter
    def locations(self) -> pulumi.Output['outputs.URLFilteringRulesLocations']:
        """
        The locations to which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        Name of the Firewall Filtering policy rule
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def order(self) -> pulumi.Output[int]:
        """
        Order of execution of rule with respect to other URL Filtering rules
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="overrideGroups")
    def override_groups(self) -> pulumi.Output['outputs.URLFilteringRulesOverrideGroups']:
        """
        Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any group.
        """
        return pulumi.get(self, "override_groups")

    @property
    @pulumi.getter(name="overrideUsers")
    def override_users(self) -> pulumi.Output['outputs.URLFilteringRulesOverrideUsers']:
        """
        Name-ID pairs of users for which this rule can be overridden. Applicable only if blockOverride is set to `true`, action is `BLOCK` and overrideGroups is not set.If this overrideUsers is not set, `BLOCK` action can be overridden for any user.
        """
        return pulumi.get(self, "override_users")

    @property
    @pulumi.getter
    def protocols(self) -> pulumi.Output[Sequence[str]]:
        """
        Protocol criteria. Supported values: `SMRULEF_ZPA_BROKERS_RULE`, `ANY_RULE`, `TCP_RULE`, `UDP_RULE`, `DOHTTPS_RULE`, `TUNNELSSL_RULE`, `HTTP_PROXY`, `FOHTTP_RULE`, `FTP_RULE`, `HTTPS_RULE`, `HTTP_RULE`, `SSL_RULE`, `TUNNEL_RULE`.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter
    def rank(self) -> pulumi.Output[Optional[int]]:
        """
        Admin rank of the admin who creates this rule
        """
        return pulumi.get(self, "rank")

    @property
    @pulumi.getter(name="requestMethods")
    def request_methods(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        Request method for which the rule must be applied. If not set, rule will be applied to all methods
        """
        return pulumi.get(self, "request_methods")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Output[int]:
        """
        URL Filtering Rule ID
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter(name="sizeQuota")
    def size_quota(self) -> pulumi.Output[Optional[int]]:
        """
        Size quota in KB beyond which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        """
        return pulumi.get(self, "size_quota")

    @property
    @pulumi.getter
    def state(self) -> pulumi.Output[Optional[str]]:
        """
        Rule State
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="timeQuota")
    def time_quota(self) -> pulumi.Output[Optional[int]]:
        """
        Time quota in minutes, after which the URL Filtering rule is applied. If not set, no quota is enforced. If a policy rule action is set to `BLOCK`, this field is not applicable.
        """
        return pulumi.get(self, "time_quota")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> pulumi.Output['outputs.URLFilteringRulesTimeWindows']:
        """
        The time interval in which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="urlCategories")
    def url_categories(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        List of URL categories for which rule must be applied
        """
        return pulumi.get(self, "url_categories")

    @property
    @pulumi.getter(name="userAgentTypes")
    def user_agent_types(self) -> pulumi.Output[Optional[Sequence[str]]]:
        return pulumi.get(self, "user_agent_types")

    @property
    @pulumi.getter
    def users(self) -> pulumi.Output['outputs.URLFilteringRulesUsers']:
        """
        The users to which the Firewall Filtering policy rule applies
        """
        return pulumi.get(self, "users")

    @property
    @pulumi.getter(name="validityEndTime")
    def validity_end_time(self) -> pulumi.Output[Optional[int]]:
        """
        If `enforceTimeValidity` is set to true, the URL Filtering rule will cease to be valid on this end date and time.
        """
        return pulumi.get(self, "validity_end_time")

    @property
    @pulumi.getter(name="validityStartTime")
    def validity_start_time(self) -> pulumi.Output[Optional[int]]:
        """
        If enforceTimeValidity is set to true, the URL Filtering rule will be valid starting on this date and time.
        """
        return pulumi.get(self, "validity_start_time")

    @property
    @pulumi.getter(name="validityTimeZoneId")
    def validity_time_zone_id(self) -> pulumi.Output[Optional[str]]:
        """
        If `enforceTimeValidity` is set to true, the URL Filtering rule date and time will be valid based on this time zone ID.
        """
        return pulumi.get(self, "validity_time_zone_id")

